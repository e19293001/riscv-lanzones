#+LATEX_HEADER_EXTRA: \usepackage{tikz-timing}[2009/12/09]
#+LATEX_HEADER_EXTRA: \usetikztiminglibrary[new={char=Q,reset char=R}]{counters}
#+LATEX_HEADER_EXTRA: \usetikzlibrary{shapes,arrows}
#+LATEX_HEADER_EXTRA: \usepackage[active,tightpage]{preview}
#+LATEX_HEADER_EXTRA: \setlength{\PreviewBorder}{5mm}

#+LATEX_HEADER_EXTRA: \definecolor{bgblue}{rgb}{0.5,0.9,0.9}
#+LATEX_HEADER_EXTRA: \definecolor{bgred}{rgb}{1,0.6,0.6}
#+LATEX_HEADER_EXTRA: \definecolor{fgblue}{rgb}{0,0,0.6}
#+LATEX_HEADER_EXTRA: \definecolor{bgred}{rgb}{0.6,,0}

* RISC-V 32I Instruction Set Implementation

This document describes the design implementation specifications
of RISC-V 32I.

** Top Level Architecture

** Hand Shake
*** External Hand Shake
**** Read Hand Shake
#+CAPTION: <<Figure_1>>
#+NAME: fig: <<Figure_1>>
#+BEGIN_LATEX
    \begin{tikztimingtable} [
    %    table/grid,
        timing/slope=0.15,
        timing/coldist=2pt,
        xscale=2.05,yscale=1.1,
        semithick
    ]

      \scriptsize clk & 15{C} \\ 
      o\_rdy & LLLLLHHHHLLLL \\
      i\_ack & LLLLLLLHHLLLL \\
      i\_addr & 7U 2D{$VALID$} 4U \\
      i\_data & 7U 2D{$VALID$} 4U \\
    \end{tikztimingtable}
#+END_LATEX

[[Figure_1]] shows a two way handshake for the read channel.
**** Write Hand Shake
#+BEGIN_LATEX

    \begin{tikztimingtable} [
    %    table/grid,
        timing/slope=0.15,
        timing/coldist=2pt,
        xscale=2.05,yscale=1.1,
        semithick
    ]

      \scriptsize clk & 15{C} \\ 
      outputAddress & 5U 4D{0x00} 4U 2D{} \\
      outputWdata & 15U \\
      outputWnR & LLLLLLLLLLLLLLL \\
      outputSelect & LLLLLHH N(A) HHLL LL HH \\
      inputRdata & 7U 2D{0x3005} N(C) 6U \\
      inputValid & LLLLLLLHH N(B) 6L \\
      \\
      regState & 3D{$P\_IDLE$} 6D{$P\_FETCH$} 2D{\scriptsize $P\_DECODE$} 2D{\scriptsize $P\_EXECUTE$} 2D{$P\_FETCH$} \\
      combAddressSelect & 3D{$NONE$} 6D{$PC$} 6D{$NONE$} \\ 
      combOutputAddressEn & LLLHHLLLLLLLLHH \\
      enInstruction & LLLLLLLHH 6L \\
      regInstruction & 9U 4D{0x3005} 2U \\
      w\_asp & LLLLLLLLLHHHHLL \\
      \\
      enStackPtr & 11L HH 2L \\
      regStackPtr & 13D{0xFFFE} 2D{0xFFFF} \\
      enPrgCntr & 11L HH 2L \\
      regPrgCntr & 13D{0x0000} 2D{0x0001} \\
      \extracode
    \end{tikztimingtable}
#+END_LATEX

*** Internal Hand Shake
** Instructions 
*** LUI
#+BEGIN_LATEX
    \begin{tikztimingtable} [
    %    table/grid,
        timing/slope=0.15,
        timing/coldist=2pt,
        xscale=2.05,yscale=1.1,
        semithick
    ]

      \scriptsize clk & 15{C} \\ 
      outputAddress & 5U 4D{0x00} 4U 2D{} \\
      outputWdata & 15U \\
      outputWnR & LLLLLLLLLLLLLLL \\
      outputSelect & LLLLLHH N(A) HHLL LL HH \\
      inputRdata & 7U 2D{0x3005} N(C) 6U \\
      inputValid & LLLLLLLHH N(B) 6L \\
      \\
      regState & 3D{$P\_IDLE$} 6D{$P\_FETCH$} 2D{\scriptsize $P\_DECODE$} 2D{\scriptsize $P\_EXECUTE$} 2D{$P\_FETCH$} \\
      combAddressSelect & 3D{$NONE$} 6D{$PC$} 6D{$NONE$} \\ 
      combOutputAddressEn & LLLHHLLLLLLLLHH \\
      enInstruction & LLLLLLLHH 6L \\
      regInstruction & 9U 4D{0x3005} 2U \\
      w\_asp & LLLLLLLLLHHHHLL \\
      \\
      enStackPtr & 11L HH 2L \\
      regStackPtr & 13D{0xFFFE} 2D{0xFFFF} \\
      enPrgCntr & 11L HH 2L \\
      regPrgCntr & 13D{0x0000} 2D{0x0001} \\
      \extracode
    \end{tikztimingtable}
#+END_LATEX

* Test
** LW
31    20 19   15 14   12 11   7 6      0
_______  ______  _______ ______ _______   
  imm     rs1      func    rd   opcode

inst[31:20] = imm[11:0]
inst[19:15] = rs1
inst[14:12] = funct3
inst[11:7] = rd
inst[6:0] = opcode

Example:
LW x2,x3,0x010

imm = 0000 0001 0000
rs1 = 00011
funct3 = 010
rd = 00010
opcode = 0000011

000000010000 00011 010 00010 0000011

0000 0001 0000 0001 1010 0001 0000 0011
   0    1    0    1    A    1    0    3

** ADD

ADD rd,rs1,rs2

31    25 24    20 19   15 14  12 11    7 6    0
________ ________ _______ ______ _______ ______
 funct7    rs2      rs1   funct3   rd    opcode

funct7 = inst[31:25]
rs2 = inst[24:20]
rs1 = inst[19:15]
funct3 = inst[14:12]
rd = inst[11:7]
opcode = inst[6:0]

*** Example

**** ADD x4,x3,x2

Add x3 and x2 then store the result to x4

funct7 = 0000000
rs2 = 00010
rs1 = 00011
funct3 = 000
rd = 00100
opcode = 0110011

0000000 00010 00011 000 00100 0110011

0000 0000 0010 0001 1000 0010 0011 0011
   0    0    2    1    8    2    3    3

00218233

** LUI

31     12 11  7 6    0
_________ _____ ______
   imm     rd   opcode

imm = inst[31:12]
rd = inst[11:7]
opcode = inst[6:0]

*** Example
**** Load 3 to x3

LUI x3,0x3

imm = 0000 0000 0000 0000 0011
rd = 00011
opcode = 0110111

00000000000000000011000110110111

0000 0000 0000 0000 0011 0001 1011 0111
   0    0    0    0    3    1    B    7

000031B7

**** Load 2 to x2

LUI x2,0x2

imm = 0000 0000 0000 0000 0010
rd = 00010
opcode = 0110111

00000000000000000010000100110111

0000 0000 0000 0000 0010 0001 0011 0111
   0    0    0    0    2    1    3    7

00002137


** SW

SW rs1,rs2,imm

31    25 24   20 19    15 14   12 11   7 6    0
________ _______ ________ _______ ______ ______
  imm      rs2     rs1     funct3  imm   opcode

*** Example

**** SW x2,x0,imm

Store the contents of register x2 to memory address 0x1000

imm = 0000 0000 1000
rs1 = 00000
rs2 = 00010
funct3 = 010
opcode = 0100011

imm = {inst[31:25],inst[11:7]}
rs2 = inst[24:20]
rs1 = inst[19:15]
funct3 = inst[14:12]
opcode = inst[6:0]

0000000 00010 00000 010 01000 0100011

0000 0000 0010 0000 0010 0100 0010 0011
   0    0    2    0    2    4    2    3

00202423



